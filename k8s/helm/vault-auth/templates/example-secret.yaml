{{- if false -}}

# example of a static secret that leverages this chart
# where .Values.authMethods[x].vaultAuthName is specified as
# in-cluster-k8s-auth
#
# note that .Release.Namespace is your APP namespace and this CRD goes in with
# your app
---
apiVersion: secrets.hashicorp.com/v1beta1
kind: VaultStaticSecret
metadata:
  name: static-secret-reference
  namespace: {{ .Release.Namespace }}
spec:
  type: kv-v2

  # name of the KV storage engine
  mount: in-cluster

  # takes all keys in this "dir" and puts them into an opaque secret
  path: path/to/app/env
  destination:
    name: app-env-secrets
    create: true

  refreshAfter: 30s

  # VERY IMPORTANT - VSO operator needs to know _which_ NS our auth lives in
  vaultAuthRef: {{ .Release.Namespace -}}/in-cluster-k8s-auth

# after creating a new k8s auth method
#
# 0. create a new policy in vault, say: app-deploy-policy
# 1. create a new role in that k8s auth method UI
# 2. alias source name: serviceaccount_name
#    audience: vault
#    bound service account names: serviceAccount in your APP namespace (just its name, no <namespace>/ prepended
#    bound service account namespace: app namespace
#    tokens --> generated token policies: app-deploy-policy (from step 0 above)
#
# the token policy that you create above can look something like:
#
# # app-deploy-policy
# path "in-cluster/data/path/to/app/*" {
#   capabilities = ["read", "list"]
# }
#
# note the /data in the path specific to kvv2 storage engines.

{{- end -}}
